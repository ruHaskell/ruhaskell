<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content>
        <meta name="author" content>
        <link rel="icon" href="../../../../../static/images/favicon.ico">

        <title>RPC на основе WAI</title>

        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">

        <link href="../../../../../static/css/default.css" rel="stylesheet">

        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>

        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://ruhaskell.org/feed.xml" />

        <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
    </head>

  <body>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-58217738-1', 'auto');
      ga('send', 'pageview');

    </script>

    <div class="container">
        <nav class="navbar navbar-default navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <div id="ruhaskell-logo">
                <a class="navbar-brand" href="../../../../../" title="Домой">
                  <img alt="ruHaskell" src="../../../../../static/images/logo.png" width="60">
                </a>
              </div>
            </div>

            <div id="navbar" class="collapse navbar-collapse">
              <ul class="nav navbar-nav">
                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Публикации<span class="caret"></span>
                  </a>
                  <ul class="dropdown-menu" role="menu">
                    <li>
                        <a href="../../../../../archive.html">
                            <span class="archive-link">
                                <span class="fa fa-pencil"></span>
                            </span>Статьи
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../tags.html">
                            <span class="tags-link">
                                <span class="fa fa-tags"></span>
                            </span>Теги
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../categories.html">
                            <span class="categories-link">
                                <span class="fa fa-star"></span>
                            </span>Категории
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../authors.html">
                            <span class="authors-link">
                                <span class="fa fa-users"></span>
                            </span>Авторы
                        </a>
                    </li>
                  </ul>
                </li>

                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Общение<span class="caret"></span>
                  </a>
                  <ul class="dropdown-menu" role="menu">
                    <li>
                        <a href="https://gitter.im/ruHaskell/forall" target="_blank">
                            <span class="chat-link">
                                <span class="fa fa-smile-o"></span>
                            </span>Чат
                        </a>
                    </li>
                    <li>
                        <a href="http://forum.ruhaskell.org" target="_blank">
                            <span class="group-link">
                                <span class="fa fa-group"></span>
                            </span>Форум
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../maillist.html">
                            <span class="group-link">
                                <span class="fa fa-group"></span>
                            </span>Список рассылки
                        </a>
                    </li>
                  </ul>
                </li>

                <li><a href="../../../../../links.html">Ссылки</a></li>
              </ul>

              <ul class="nav navbar-nav navbar-right">
                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Присоединяйтесь!<span class="caret"></span>
                  </a>
                  <ul class="dropdown-menu" role="menu">
                    <li>
                        <a href="https://twitter.com/RuHaskell" target="_blank">
                            <span id="twitter-link">
                                <span class="fa fa-twitter-square"></span>
                            </span>Twitter
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/ruHaskell/ruhaskell" target="_blank">
                            <span id="github-link">
                                <span class="fa fa-github-square"></span>
                            </span>GitHub
                        </a>
                    </li>
                    <li>
                        <a href="https://plus.google.com/communities/117343381540538069054" target="_blank">
                            <span id="google-plus-link">
                                <span class="fa fa-google-plus-square"></span>
                            </span>Google+
                        </a>
                    </li>
                    <li>
                        <a href="../../../../../feed.xml">
                            <span id="rss-link">
                                <span class="fa fa-rss-square"></span>
                            </span>RSS
                        </a>
                    </li>
                    <li>
                        <a href="https://itunes.apple.com/ru/podcast/banany-i-linzy/id1037879859" target="_blank">
                            <span id="itunes-rss-link">
                                <span class="fa fa-rss-square"></span>
                            </span>iTunes
                        </a>
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </nav>

        <div id="content">
            <h1>RPC на основе WAI</h1>

<div class="row">
    <div class="col-xs-9 col-sm-8 col-md-8 col-lg-8">
        <div class="post-info">
            <strong>let</strong> author&nbsp;&nbsp;&nbsp;= "<a href="../../../../../authors/%D0%90%D0%BB%D0%B5%D0%BA%D1%81%D0%B5%D0%B9%20%D0%9F%D0%B8%D1%80%D0%BE%D0%B3%D0%BE%D0%B2.html">Алексей Пирогов</a>"<br />
            &nbsp;&nbsp;&nbsp;&nbsp;date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= fromGregorian 2015 sep 01<br />
            &nbsp;&nbsp;&nbsp;&nbsp;category = "<a href="../../../../../categories/web.html">Веб</a>"<br />
            &nbsp;&nbsp;&nbsp;&nbsp;tags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [&quot;<a href="../../../../../tags/WAI.html">WAI</a>&quot;]
        </div>
    </div>

    <div class="col-xs-3 col-sm-4 col-md-4 col-lg-4">
        
            <div class="href-to-original">
                <a href="https://astynax.github.io/posts/2015-09-01-wai-rpc.html" target="_blank">Оригинал <span class="fa fa-external-link"></span></a>
            </div>
        
    </div>
</div>

<h1>Введение</h1>
<p>Сейчас web-разработка на <strong>Haskell</strong> достаточно проста, даже для новичка. Этому способствует наличие таких пакетов, как <a href="http://www.yesodweb.com/">Yesod</a> и <a href="http://snapframework.com/">Snap</a>. Но не всегда их мощь и полнота охвата необходимы. Порой от “сервера” требуется столь мало, что не хочется иметь в зависимостях подобных “монстров”, особенно в тех случаях, когда задача <em>достаточно легко</em> решаема и более простыми средствами.</p>
<p>Пусть примером послужит такая задача: требуется реализовать сервис, позволяющий вызывать на сервере некие функции и получать результат вызова, или, говоря общепринятым языком, выполнять <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a>.</p>
<p>Такую задачу можно решить, используя <a href="http://hackage.haskell.org/package/Spock">Spock</a>, <a href="http://hackage.haskell.org/package/scotty">scotty</a> или, скажем, <a href="http://hackage.haskell.org/package/servant">servant</a>, но “мы пойдем другим путем”<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BD%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B5_%D1%84%D1%80%D0%B0%D0%B7%D1%8B">©</a>!</p>
<p>Большинство библиотек для web-разработки внутри использует так называемый <strong>Web Application Interface</strong> (<a href="http://hackage.haskell.org/package/wai">WAI)</a> - обобщенный <em>протокол общения web-сервера и web-приложения</em>. Приложения, реализующие этот протокол, называют WAI-приложениями и запускают с помощью сервера wai-приложений - <a href="http://www.stackage.org/package/warp">warp</a>.</p>
<p>Реализуем же и мы простой сервис на чистом WAI!</p>
<h1>WAI-сервис</h1>
<h2>Задача</h2>
<p>Реализовать сервис вызова функций типа <code>String -&gt; String</code>. Для примера реализуем функции <code>reverse</code>, <code>upper</code> и <code>lower</code>.</p>
API будет следующим:
<ul>
<li><code>GET</code> на <code>/</code> возвращает список имен доступных функций (по одному на строку),</li>
<li><code>GET</code> на <code>/&lt;function_name&gt;</code> возвращает описание функции,</li>
<li><code>GET</code> на <code>/&lt;function_name&gt;?&lt;argument&gt;</code> возвращает результат вызова функции.</li>
</ul>
<h2>“Hello, World!”</h2>
<p>Для начала создадим проект и реализуем сервер-заглушку, отвечающий известной строкой на любой запрос. <strong>Обратите внимание:</strong> исходники проекта <a href="https://github.com/astynax/wai-rpc">доступны на github</a>.</p>
<p>Создаем проект:</p>
<pre class="shell"><code>  $ stack new wai-rpc simple --resolver lts-3.2
</code></pre>
<p><strong>ВНИМАНИЕ:</strong> предполагается, что у вас установлена утилита <a href="https://github.com/commercialhaskell/stack">stack</a>, а ключ <code>--resolver lts-3.2</code> означает, что будет использоваться снимок версии 3.2 - именно этот снимок был актуален на момент написания статьи. (подробнее о снимках можно почитать в документации к stack).</p>
<p>После создания проекта добавляем зависимости <code>http-types</code>, <code>wai</code> и <code>warp</code> в <code>.cabal</code>-файл:</p>
<pre class="shell"><code>  -- ...часть файла опущена...
  executable wai-rpc
    hs-source-dirs:      src
    main-is:             Main.hs
    default-language:    Haskell2010
    build-depends:       base &gt;= 4.7 &amp;&amp; &lt; 5,
                         http-types, wai, warp -- &lt;-- добавлено
</code></pre>
<p>Затем содержимое файла <code>src/Main.hs</code> заменяем на:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
  <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

  <span class="kw">import </span><span class="dt">Network.Wai</span>
  <span class="kw">import </span><span class="dt">Network.HTTP.Types</span> (status200, hContentType)
  <span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span> (run)

<span class="ot">  application ::</span> <span class="dt">Application</span>
  application _ respond <span class="fu">=</span> respond <span class="fu">$</span>
    responseLBS status200
                [(hContentType, <span class="st">&quot;text/plain&quot;</span>)]
                <span class="st">&quot;Hello World&quot;</span>

<span class="ot">  main ::</span> <span class="dt">IO</span> ()
  main <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;Serving...&quot;</span>
    run <span class="dv">8000</span> application</code></pre></div>
<p>К слову, этот код практически слово-в-слово повторяет <a href="http://www.yesodweb.com/book/web-application-interface#web-application-interface_hello_world">helloworld</a> от авторов библиотеки WAI ;)</p>
<p>Осталось собрать проект:</p>
<pre class="shell"><code>  $ stack build
</code></pre>
<p>И запустить:</p>
<pre class="shell"><code>  $ stack exec wai-rpc
  Serving (hit Ctrl+C to stop)...
</code></pre>
<p>Если при запущенном сервере открыть в браузере url <a href="http://localhost:8000" class="uri">http://localhost:8000</a>, то в окне отобразится ожидаемое приветствие. Сервер работает!</p>
<p>Теперь стоит разобрать, из чего же состоит наш сервер.</p>
<p><code>main</code> содержит строку</p>
<pre class="shell"><code>run 8000 application
</code></pre>
<p>Это запуск сервера <code>warp</code> на порту <code>8000</code> с единственным WAI-приложением - <code>application</code>.</p>
<p>Приложение <code>application</code> имеет тип <a href="http://haddock.stackage.org/lts-3.2/wai-3.0.3.0/Network-Wai.html#t:Application">Application</a>, который является синонимом для</p>
<pre class="shell"><code>  type Application = Request
                     -&gt; (Response -&gt; IO ResponseReceived)
                     -&gt; IO ResponseReceived
</code></pre>
<p>Здесь первый аргумент, это тип <a href="http://haddock.stackage.org/lts-3.2/wai-3.0.3.0/Network-Wai.html#t:Request">Request</a>, описывающий запрос, а второй, это “ответчик” - функция, призванная возвращать ответ <a href="http://haddock.stackage.org/lts-3.2/wai-3.0.3.0/Network-Wai.html#t:Response">Response</a> в процессе выполнения некой работы (для этого в типе монада <code>IO</code>).</p>
<p>В данном случае приложение сразу же отвечает фиксированным сообщением, поэтому тело приложения - единственный вызов ответчика <code>respond</code>.</p>
<p>Ответ же в данном случае выглядит так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  responseLBS status200
              <span class="co">-- :: Network.HTTP.Types.Status</span>
              [(hContentType, <span class="st">&quot;text/plain&quot;</span>)]
              <span class="co">-- :: [(Network.HTTP.Types.HeaderName</span>
              <span class="co">--     ,ByteString)]</span>
              <span class="st">&quot;Hello World!&quot;</span>
              <span class="co">-- :: Lazy ByteString</span></code></pre></div>
<p>Всё достаточно привычно: статус, заголовки и тело.</p>
<p>Вот, собственно и всё! Это уже вполне самостоятельный сервер, можно пускать в production :) И это не шутка - warp испытан и проверен, и, ко всему прочему, <a href="http://www.techempower.com/benchmarks/#section=data-r10&amp;hw=ec2&amp;test=json&amp;c=5&amp;f=28ougw-9zle8-0-0">весьма быстр</a> и <a href="http://www.aosabook.org/en/posa/warp.html">пригоден</a> для “вывешивания наружу” (т.е. не требует заворачивания во всякие Nginx).</p>
<h2>Маршрутизация</h2>
<p>Сервер работает, настало время решать конкретную задачу. Для начала заведем несколько вспомогательных функций для работы с ответами:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">import </span><span class="dt">Network.Wai</span> (<span class="dt">Response</span>)
  <span class="kw">import </span><span class="dt">Network.HTTP.Types</span> (<span class="dt">Status</span>, notFound404,
                             badRequest400)
  <span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">LBS</span>

  <span class="co">-- ...</span>

  responseOk, responseNotFound, responseBadRequest
<span class="ot">    ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Response</span>
  responseOk         <span class="fu">=</span> responsePlainText status200
  responseNotFound   <span class="fu">=</span> responsePlainText notFound404
  responseBadRequest <span class="fu">=</span> responsePlainText badRequest400

<span class="ot">  responsePlainText ::</span> <span class="dt">Status</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Response</span>
  responsePlainText <span class="fu">=</span>
    (<span class="ot">`responseLBS`</span> [(hContentType, <span class="st">&quot;text/plain&quot;</span>)])</code></pre></div>
<p>(в зависимости проекта нужно будет добавить <code>bytestring</code>)</p>
<p>Так как мы собираемся обрабатывать только <code>GET</code>-запросы, добавим отсечку по типу запроса с соответствующим сообщением об ошибке:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">import </span><span class="dt">Network.Wai</span> (requestMethod)
  <span class="kw">import </span><span class="dt">Network.HTTP.Types</span> (methodGet)

  application req respond <span class="fu">=</span> respond <span class="fu">$</span>
    <span class="kw">if</span> requestMethod req <span class="fu">/=</span> methodGet
    <span class="kw">then</span> responseBadRequest <span class="st">&quot;Only GET method is allowed!&quot;</span>
    <span class="kw">else</span> <span class="co">-- далее всё как раньше с учетом вспом. функций</span>
      responseOk <span class="st">&quot;Hello World&quot;</span></code></pre></div>
<p><code>GET</code>-запросы мы уже фильтруем, теперь на запрос к корневому url нужно возвращать список функций. Значит нужна библиотека функций:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>, fromList, lookup, keys)
  <span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">BS</span>
  <span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)

  <span class="co">-- ...</span>

  <span class="kw">type</span> <span class="dt">FunctionName</span>        <span class="fu">=</span> <span class="dt">BS.ByteString</span>
  <span class="kw">type</span> <span class="dt">FunctionDescription</span> <span class="fu">=</span> <span class="dt">BS.ByteString</span>
  <span class="kw">type</span> <span class="dt">FunctionArg</span>         <span class="fu">=</span> <span class="dt">BS.ByteString</span>
  <span class="kw">type</span> <span class="dt">FunctionResult</span>      <span class="fu">=</span> <span class="dt">BS.ByteString</span>
  <span class="kw">type</span> <span class="dt">FunctionSpec</span>        <span class="fu">=</span> (<span class="dt">FunctionDescription</span>
                             ,(<span class="dt">FunctionArg</span> <span class="ot">-&gt;</span> <span class="dt">FunctionResult</span>))

<span class="ot">  library ::</span> <span class="dt">Map</span> <span class="dt">FunctionName</span> <span class="dt">FunctionSpec</span>
  library <span class="fu">=</span> fromList []

<span class="ot">  getFunctionSpec ::</span> <span class="dt">FunctionName</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">FunctionSpec</span>
  getFunctionSpec <span class="fu">=</span> (<span class="ot">`lookup`</span> library)

<span class="ot">  listOfFunctions ::</span> [<span class="dt">FunctionName</span>]
  listOfFunctions <span class="fu">=</span> keys library

<span class="ot">  describe ::</span> <span class="dt">FunctionSpec</span> <span class="ot">-&gt;</span> <span class="dt">FunctionDescription</span>
  describe <span class="fu">=</span> fst

<span class="ot">  call ::</span> <span class="dt">FunctionSpec</span> <span class="ot">-&gt;</span> <span class="dt">FunctionArg</span> <span class="ot">-&gt;</span> <span class="dt">FunctionResult</span>
  call <span class="fu">=</span> snd</code></pre></div>
<p>(в зависимости проекта нужно будет добавить <code>containers</code>)</p>
<p>Самих функций пока нет, но библиотека есть, как есть и функции для работы с ней. Можно уже выводить список функций, но перед этим нужно понять, что запрос производится на “корневой” url и не содержит параметров. Добавим ветвления в наше приложение, заодно переписав <code>if</code>-ветки в виде охранных выражений:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">import </span><span class="dt">Network.Wai</span> (rawPathInfo, rawQueryString)

  <span class="co">-- ...</span>

  application req respond
    <span class="fu">|</span> requestMethod req <span class="fu">/=</span> methodGet <span class="fu">=</span>
      respond
      <span class="fu">$</span> responseBadRequest <span class="st">&quot;Only GET method is allowed!&quot;</span>

    <span class="fu">|</span> path <span class="fu">==</span> <span class="st">&quot;&quot;</span> <span class="fu">=</span>
      respond
      <span class="fu">$</span> <span class="kw">if</span> query <span class="fu">/=</span> <span class="st">&quot;&quot;</span>
        <span class="kw">then</span> responseBadRequest <span class="st">&quot;No query parameters needed!&quot;</span>
        <span class="kw">else</span> responseOk renderedListOfFunctions

    <span class="fu">|</span> otherwise <span class="fu">=</span>
      respond
      <span class="fu">$</span> responseOk <span class="st">&quot;Hello World&quot;</span>

    <span class="kw">where</span>
      query <span class="fu">=</span> rawQueryString req
      path  <span class="fu">=</span> BS.tail <span class="fu">$</span> rawPathInfo req <span class="co">-- без ведущего '/'</span>

      renderedListOfFunctions <span class="fu">=</span>
        LBS.intercalate <span class="st">&quot;\n&quot;</span>
        <span class="fu">$</span> <span class="st">&quot;Available functions:&quot;</span>
          <span class="fu">:</span> map LBS.fromStrict listOfFunctions</code></pre></div>
<p>Теперь у нашего сервера есть <strong>маршрутизация</strong>, пусть и в зачаточном виде :)</p>
<p>Проверим работу того, что уже наработано, с помощью <code>curl</code> (предполагается, что сервер запущен в другом окне терминала):</p>
<pre class="shell"><code>  $ curl http://localhost:8000
  Available functions:
</code></pre>
<pre class="shell"><code>  $ curl http://localhost:8000?asdf
  No query parameters needed!
</code></pre>
<h2>Получение описание и вызов функций</h2>
<p>Теперь корневой url обрабатывается. Настало время поиска функции в библиотеке:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  application req respond
    <span class="co">-- тут существующая маршрутизация</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span>
      respond
      <span class="fu">$</span> maybe
      (responseNotFound <span class="st">&quot;Unknown function!&quot;</span>)
      (\spec <span class="ot">-&gt;</span> responseOk
                <span class="fu">$</span> LBS.fromStrict
                <span class="fu">$</span> <span class="kw">if</span> query <span class="fu">==</span> <span class="st">&quot;&quot;</span>
                  <span class="kw">then</span> describe spec
                  <span class="kw">else</span> call spec query)
      <span class="fu">$</span> getFunctionSpec path</code></pre></div>
<p>Функций пока нет, но поиск уже работает. Проверим:</p>
<pre class="shell"><code>  $ curl http://localhost:8000/func
  Unknown function!
</code></pre>
<p>Добавим же наконец пару функций в библиотеку:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">import </span><span class="dt">Data.Char</span> (toUpper)

  <span class="co">-- ...</span>

<span class="ot">  library ::</span> <span class="dt">Map</span> <span class="dt">FunctionName</span> <span class="dt">FunctionSpec</span>
  library <span class="fu">=</span>
    fromList [(<span class="st">&quot;reverse&quot;</span>, (<span class="st">&quot;returns string with characters in reverset order&quot;</span>,
                           BS.reverse ))
             ,(<span class="st">&quot;upper&quot;</span>,   (<span class="st">&quot;returns string with each character in upper case&quot;</span>,
                           BS.map toUpper ))]</code></pre></div>
<p>И, разумеется, проверим:</p>
<pre class="shell"><code>  $ curl http://localhost:8000
  Available functions:
  reverse
  upper
</code></pre>
<pre class="shell"><code>  $ curl http://localhost:8000/reverse
  returns string with characters in reverset order
</code></pre>
<pre class="shell"><code>  $ curl http://localhost:8000/reverse?Hello+World
  dlroW olleH
</code></pre>
<p>Готово! Есть функции, и их можно вызывать удалённо!</p>
<h2>Финальные штрихи</h2>
<p>Сервер у нас есть, но неплохо было бы видеть какие запросы он получает и что на них отвечает, т.е. нам нужно логирование. Существует готовый пакет <a href="http://haddock.stackage.org/lts-3.2/wai-logger-2.2.4.1/Network-Wai-Logger.html">wai-logger</a>, однако для практики мы напишем свою реализацию логирования - тоже простейшую.</p>
<p>Когда при работе с WAI-приложениями возникает необходимость сделать что-то с запросами и/или ответами на них, на сцену выходит тип <a href="http://haddock.stackage.org/lts-3.2/wai-3.0.3.0/Network-Wai.html#t:Middleware">Middleware</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">Middleware</span><span class="ot"> ::</span> <span class="dt">Application</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></code></pre></div>
<p>Middleware - это преобразователь приложений, настоящая <em>функция высшего порядка</em>! Как же такие преобразователи пишутся? Довольно просто:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">import </span><span class="dt">Network.Wai</span> (<span class="dt">Middleware</span>, responseStatus)
  <span class="kw">import </span><span class="dt">Network.HTTP.Types</span> (statusCode)

  <span class="co">-- ...</span>

<span class="ot">  withLogging ::</span> <span class="dt">Middleware</span>
  withLogging app req respond <span class="fu">=</span>
    app req <span class="fu">$</span> \response <span class="ot">-&gt;</span> <span class="kw">do</span>
      putStrLn <span class="fu">$</span> statusOf response <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> query
      respond response
    <span class="kw">where</span>
      query <span class="fu">=</span> BS.unpack
            <span class="fu">$</span> BS.concat [ rawPathInfo    req
                        , rawQueryString req ]
      statusOf <span class="fu">=</span> show <span class="fu">.</span> statusCode <span class="fu">.</span> responseStatus

   main <span class="fu">=</span> <span class="kw">do</span>
     putStrLn <span class="fu">...</span>
     run <span class="dv">8000</span> <span class="fu">$</span> withLogging application</code></pre></div>
<p>Ничего сверх-естественного, оборачивание вызова функции, как оно есть.</p>
<p>Выглядит вывод logger’а примерно так:</p>
<pre class="shell"><code>  $ stack exec wai-rpc
  Serving (hit Ctrl+C to stop)...
  200: /reverse?Hello%20World
  200: /
  404: /asdf
  400: /?asdf
  ...
</code></pre>
<p>Подобным образом можно осуществлять маршрутизацию, проверку на наличие, или отсутствие cookies, оптимизацию(сжатие) ответов и кэширование запросов. Такой подход, на мой взгляд, очень композируем да и просто и элегантен!</p>
<h1>Заключение</h1>
<p>Даже такой простой пример позволяет понять, что разработка сервисов на “голом” WAI не только довольно проста, но и вполне удобна и приятна :)</p>

<div id="socialButtons">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ru">Твитнуть</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    <div class="g-plus" data-action="share" data-annotation="bubble"></div>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ruhaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    

        </div>

        <div id="searchForm">
            <script>
              (function() {
                var cx = '007697214108744450483:w49n7qbvpdy';
                var gcse = document.createElement('script');
                gcse.type = 'text/javascript';
                gcse.async = true;
                gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                    '//www.google.com/cse/cse.js?cx=' + cx;
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(gcse, s);
              })();
            </script>
            <gcse:search></gcse:search>
        </div>

        <footer class="footer">
            Сайт работает на <strong><a href="http://jaspervdj.be/hakyll/" target="_blank">Hakyll</a></strong> и живёт на <strong><a href="https://github.com/ruHaskell/ruhaskell" target="_blank">GitHub</a></strong>.
            <div class="stargaze">
                <a data-count-api="/repos/ruHaskell/ruhaskell#stargazers_count" data-count-href="/ruHaskell/ruhaskell/stargazers" data-icon="octicon-star" href="https://github.com/ruHaskell/ruhaskell" class="github-button">Star</a>

                <span style="padding-left: 20px;"></span>

                <a data-count-api="/repos/ruHaskell/ruhaskell#forks_count" data-count-href="/ruHaskell/ruhaskell/network" data-icon="octicon-git-branch" href="https://github.com/ruHaskell/ruhaskell" class="github-button">Fork</a>
            </div>

            <div class="copyright-note">
                Исходный код данного сайта, а также все опубликованные на нём материалы распространяются на условиях <a href="https://github.com/ruHaskell/ruhaskell/blob/master/LICENSE" target="_blank">свободной лицензии MIT</a>.
            </div>
        </footer>
    </div>

<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'ruhaskell'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

  </body>
</html>
